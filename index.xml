<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>violetear</title>
    <link>https://violetear.org/</link>
    <description>Recent content on violetear</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright> </copyright>
    <lastBuildDate>Sat, 11 Mar 2017 10:11:01 +0000</lastBuildDate>
    
	<atom:link href="https://violetear.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How it works</title>
      <link>https://violetear.org/post/how-it-works/</link>
      <pubDate>Sat, 11 Mar 2017 10:11:01 +0000</pubDate>
      
      <guid>https://violetear.org/post/how-it-works/</guid>
      <description>The router is capable of handle any kind or URI, static, dynamic or catchall and based on the HTTP request Method accept or discard the request.
For example, suppose we have an API that exposes a service that allows to ping any IP address.
To handle only GET requests for any IPv4 addresss:
http://api.violetear.org/command/ping/127.0.0.1 \______/\___/\________/ | | | static | dynamic  The router HandlerFunc would be:
router.HandleFunc(&amp;quot;/command/ping/:ip&amp;quot;, ipHandler, &amp;quot;GET&amp;quot;)  For this to work, first the regex matching :ip should be added:</description>
    </item>
    
    <item>
      <title>Usage</title>
      <link>https://violetear.org/post/usage/</link>
      <pubDate>Sat, 11 Mar 2017 11:05:52 +0100</pubDate>
      
      <guid>https://violetear.org/post/usage/</guid>
      <description>Basic example:
package main import ( &amp;quot;github.com/nbari/violetear&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; ) func catchAll(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;quot;I&#39;m catching all\n&amp;quot;)) } func handleGET(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;quot;I handle GET requests\n&amp;quot;)) } func handlePOST(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;quot;I handle POST requests\n&amp;quot;)) } func handleUUID(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;quot;I handle dynamic requests\n&amp;quot;)) } func main() { router := violetear.New() router.LogRequests = true router.RequestID = &amp;quot;Request-ID&amp;quot; uuid := `[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}` router.AddRegex(&amp;quot;:uuid&amp;quot;, uuid) router.</description>
    </item>
    
    <item>
      <title>Middleware</title>
      <link>https://violetear.org/post/middleware/</link>
      <pubDate>Sat, 11 Mar 2017 11:04:30 +0100</pubDate>
      
      <guid>https://violetear.org/post/middleware/</guid>
      <description>Violetear uses Alice to handle middleware.
Example:
package main import ( &amp;quot;context&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;github.com/nbari/violetear&amp;quot; &amp;quot;github.com/nbari/violetear/middleware&amp;quot; ) func commonHeaders(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Header().Set(&amp;quot;X-app-Version&amp;quot;, &amp;quot;1.0&amp;quot;) next.ServeHTTP(w, r) }) } func middlewareOne(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { log.Println(&amp;quot;Executing middlewareOne&amp;quot;) ctx := context.WithValue(r.Context(), &amp;quot;m1&amp;quot;, &amp;quot;m1&amp;quot;) ctx = context.WithValue(ctx, &amp;quot;key&amp;quot;, 1) next.ServeHTTP(w, r.WithContext(ctx)) log.Println(&amp;quot;Executing middlewareOne again&amp;quot;) }) } func middlewareTwo(next http.Handler) http.Handler { return http.</description>
    </item>
    
    <item>
      <title>Context &amp; Named parameters</title>
      <link>https://violetear.org/post/context-named/</link>
      <pubDate>Sat, 11 Mar 2017 11:04:29 +0100</pubDate>
      
      <guid>https://violetear.org/post/context-named/</guid>
      <description>In some cases there is a need to pass data across handlers/middlewares, for doing this Violetear uses net/context
Example:
package main import ( &amp;quot;context&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;github.com/nbari/violetear&amp;quot; ) func catchAll(w http.ResponseWriter, r *http.Request) { // Get &amp;amp; print the content of named-param * params := r.Context().Value(violetear.ParamsKey).(violetear.Params) fmt.Fprintf(w, &amp;quot;CatchAll value:, %q&amp;quot;, params[&amp;quot;*&amp;quot;]) } func handleUUID(w http.ResponseWriter, r *http.Request) { // get router params params := r.Context().Value(violetear.ParamsKey).(violetear.Params) // using GetParam uuid := violetear.</description>
    </item>
    
    <item>
      <title>Versioning</title>
      <link>https://violetear.org/post/versioning/</link>
      <pubDate>Sat, 11 Mar 2017 11:04:28 +0100</pubDate>
      
      <guid>https://violetear.org/post/versioning/</guid>
      <description>Violetear handle versions by using the Accept: application/vnd.* header.
This means that the URL won&amp;rsquo;t change, therefore instead of specifying the version on the URL something like this:
https://acme.tld/api/v2/foo  It can always be:
https://acme.tld/api/foo  But based on the request Accept: application/vnd.* header the corresponding version will be served:
https://acme.tld/api/foo ===&amp;gt; GET /api/foo HTTP/1.1 Accept: application/vnd.acme.v2  Using the Fragment identifier # To define what version to use, the # fragment identifier is used when declaring the routes.</description>
    </item>
    
    <item>
      <title>RequestID</title>
      <link>https://violetear.org/post/requestid/</link>
      <pubDate>Sat, 11 Mar 2017 11:04:14 +0100</pubDate>
      
      <guid>https://violetear.org/post/requestid/</guid>
      <description>To keep track of the &amp;ldquo;requests&amp;rdquo; an existing &amp;ldquo;request ID&amp;rdquo; header can be used, if the header name for example is X-Appengine-Request-Log-Id therefore to continue using it, the router needs to know the name, example:
router := violetear.New() router.RequestID = &amp;quot;X-Appengine-Request-Log-Id&amp;quot;  If the proxy is using another name, for example RID then use something like:
router := violetear.New() router.RequestID = &amp;quot;RID&amp;quot;  If router.RequestID is not set, no &amp;ldquo;request ID&amp;rdquo; is going to be added to the headers.</description>
    </item>
    
    <item>
      <title>NotFoundHandler</title>
      <link>https://violetear.org/post/notfoundhandler/</link>
      <pubDate>Sat, 11 Mar 2017 11:03:43 +0100</pubDate>
      
      <guid>https://violetear.org/post/notfoundhandler/</guid>
      <description>For defining a custom http.Handler to handle 404 Not Found example:
... func my404() http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { http.Error(w, &amp;quot;my custom 404 message&amp;quot;, 404) }) } func main() { router := violetear.New() router.NotFoundHandler = my404() ...  </description>
    </item>
    
    <item>
      <title>NotAllowedHandler</title>
      <link>https://violetear.org/post/notallowedhandler/</link>
      <pubDate>Sat, 11 Mar 2017 11:03:40 +0100</pubDate>
      
      <guid>https://violetear.org/post/notallowedhandler/</guid>
      <description>NotAllowedHandler configurable http.Handler which is called when method not allowed:
405 Method Not Allowed  Example:
... func my405() http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { http.Error(w, &amp;quot;my custom 405 message&amp;quot;, 405) }) } func main() { router := violetear.New() router.NotAllowedHandler = my405() ...  </description>
    </item>
    
    <item>
      <title>PanicHandler</title>
      <link>https://violetear.org/post/panichandler/</link>
      <pubDate>Sat, 11 Mar 2017 11:03:40 +0100</pubDate>
      
      <guid>https://violetear.org/post/panichandler/</guid>
      <description>PanicHandler function to handle panics.
Example:
func myPanicHandler() http.HandlerFunc { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { http.Error(w, &amp;quot;custom panic message&amp;quot;, 500) }) } router := violetear.New() router.PanicHandler = myPanicHandler()  </description>
    </item>
    
    <item>
      <title>Benchmarks and profiling</title>
      <link>https://violetear.org/post/allocs/</link>
      <pubDate>Sat, 11 Mar 2017 11:03:40 +0200</pubDate>
      
      <guid>https://violetear.org/post/allocs/</guid>
      <description>Go is fast, but when doing things carefully, besides being faster is very light.
The history about violetear is not much different from many others - an HTTP router capable of handling any requests.
One of the main constraints found at the beginning was how to deal with static and dynamic URL&amp;rsquo;s. Let&amp;rsquo;s face it, if you want to replace an important component of your current architecture you should try to break as less as possible - highly trained monkeys hate changes.</description>
    </item>
    
    <item>
      <title>violetear</title>
      <link>https://violetear.org/about/</link>
      <pubDate>Sat, 11 Mar 2017 09:57:00 +0100</pubDate>
      
      <guid>https://violetear.org/about/</guid>
      <description> What is violetear? An HTTP router, extending the capabilities of the default go mux
Features  0 memory allocations for static routes. Common context between middleware. Context &amp;amp; Named parameters Easy middleware (satisfies the http.Handler interface). HTTP/2 native support Push Example Support for static and dynamic routing. Trace Request-ID per request. Versioning application/vnd.*  </description>
    </item>
    
  </channel>
</rss>